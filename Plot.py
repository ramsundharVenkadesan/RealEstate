import json, re, os, sys
import pandas as pd
from collections import Counter
import matplotlib.pyplot as plt

JSON_FILE_NAME = "globe.json" # JSON file generated by Spider.py
OUTPUT_FILE_NAME = 'price_analysis_globe.jpeg' # Plotting output JPEG


def clean_and_convert_to_float(value): # Cleans a string value by prioritizing fraction handling (e.g., "1/2"), then removing non-numeric characters for conversion to float.
    if value is None: return None # Returns None if conversion fails.

    s = str(value).strip() # Strip whitespace from both ends

    if '/' in s: # Priority 1: Handle fractions (e.g., "1/2", "3/4")
        parts = s.split('/')
        if len(parts) == 2:
            try:
                numerator = float(parts[0].strip())
                denominator = float(parts[1].strip())
                if denominator != 0:
                    return numerator / denominator
            except ValueError:
                # If conversion fails (e.g., "N/A"), fall through to next logic
                pass

    try: # Priority 2: Handle standard numbers (e.g., "$1,200,000", "4.5", "5")
        cleaned_value = re.sub(r'[^\d.]', '', s) # Remove characters that are not digits or a decimal point
        if cleaned_value: return float(cleaned_value) # Return the cleaned value if it's not empty'
    except ValueError: # If conversion fails (e.g., "N/A"), return None
        pass

    return None # Return None if all priorities fail


def calculate_stats(df): # Calculates the required statistics from the DataFrame.

    # Use the cleaned columns for calculation
    prices = df['price'].dropna().tolist()
    beds = df['beds'].dropna().tolist()
    baths = df['baths'].dropna().tolist()
    sq_fts = df['sq_ft'].dropna().tolist()

    # Use the original agency column (not cleaned)
    agencies = df['agency'].dropna().tolist()

    # Calculate Averages
    avg_price = sum(prices) / len(prices) if prices else 0
    avg_beds_float = sum(beds) / len(beds) if beds else 0
    avg_baths = sum(baths) / len(baths) if baths else 0
    avg_sqft = sum(sq_fts) / len(sq_fts) if sq_fts else 0

    # Average Beds (Rounded and cast to integer as requested)
    avg_beds_int = int(round(avg_beds_float))

    # Find Real Estate Agency with Most Listings
    most_common_agency = "N/A"
    agency_count = 0
    if agencies:
        agency_counts = Counter(agencies)
        # most_common(1) returns a list of the single most common item and its count: [('Agency Name', count)]
        most_common_agency, agency_count = agency_counts.most_common(1)[0]

    # Format the stats for the plot text box
    return {
        "avg_price": f"${avg_price:,.2f}",
        "avg_beds": avg_beds_int,
        "avg_baths": f"{avg_baths:.2f}",
        "avg_sqft": f"{avg_sqft:,.2f}",
        "most_common_agency": most_common_agency,
        "agency_text": f"{most_common_agency} ({agency_count} Listings)"
    }


def generate_analysis_plot(json_file_name, output_file_name):
    print(f"Generating plot from data in: {json_file_name}")

    if not os.path.exists(json_file_name):
        print(f"Error: JSON file '{json_file_name}' not found. Please ensure it is in the current directory.")
        return

    try:
        with open(json_file_name, 'r', encoding='utf-8') as f:
            data = json.load(f)
    except json.JSONDecodeError:
        print(f"Error: Could not decode JSON from '{json_file_name}'. Check if the file is valid.")
        return
    except Exception as e:
        print(f"An unexpected error occurred while reading the file: {e}")
        return

    if not data:
        print(f"Error: The JSON file '{json_file_name}' is empty.")
        return

    # Convert the list of dicts to a pandas DataFrame
    df = pd.DataFrame(data)

    # 1. Data Cleaning
    print("Applying data cleaning and conversion...")
    df['price'] = df['price'].apply(clean_and_convert_to_float)
    df['beds'] = df['beds'].apply(clean_and_convert_to_float)
    df['baths'] = df['baths'].apply(clean_and_convert_to_float)
    df['sq_ft'] = df['sq_ft'].apply(clean_and_convert_to_float)

    # Filter all rows with valid price data
    df_filtered = df.dropna(subset=['price']).copy()

    if df_filtered.empty:
        print("Error: No valid price data found after cleaning. Cannot generate plot.")
        return

    # 2. Prepare Data for Plotting (ALL Listings, Sorted)
    print("Sorting listings by price...")
    # Sort ALL valid listings by price (lowest to highest)
    df_plot = df_filtered.sort_values(by='price', ascending=True).reset_index(drop=True)

    # 3. Calculate Statistics (using the full cleaned dataset)
    stats = calculate_stats(df_filtered)
    # Extract float value for the average price line
    avg_price_float = float(stats['avg_price'].replace('$', '').replace(',', ''))
    total_listings = len(df_plot)

    # 4. Generate the Line Graph
    print(f"Generating plot and saving to '{output_file_name}'...")
    # Increased figure size to better accommodate annotations
    plt.figure(figsize=(16, 9))
    ax = plt.gca()

    # Plot all sorted prices
    plt.plot(
        df_plot.index,
        df_plot['price'],
        marker='o',  # Use markers for data points
        linestyle='-',  # Connect markers with a line
        color='#1f77b4',
        linewidth=1.5,
        markersize=4,
        label=f'Individual Listing Price (N={total_listings})'
    )

    # Add a line for the overall average price for context
    plt.axhline(avg_price_float, color='#d62728', linestyle='--', linewidth=2,
                label=f'Average Price ({stats["avg_price"]})')

    # 5. Add Annotations for ALL Listings (Price and Address)
    # WARNING: This will likely result in a heavily cluttered plot.
    for index, row in df_plot.iterrows():
        # Format the data for the label (Price and Address only, as requested)
        price_str = f"${row['price']:,.0f}" if pd.notna(row['price']) else "N/A"
        address_str = row['address'] if row['address'] else "Address N/A"

        # Build the annotation text string
        annotation_text = f"Price: {price_str}\n{address_str}"

        # Coordinates for the point on the plot
        x_coord = index
        y_coord = row['price']

        # Use very small font and minimal offset for annotations
        ax.annotate(
            annotation_text,
            xy=(x_coord, y_coord),
            xytext=(3, 5),  # Minimal offset (in points)
            textcoords='offset points',
            ha='left',
            fontsize=5,  # Very small font to reduce clutter
            bbox=dict(boxstyle="round,pad=0.2", fc="white", alpha=0.7, ec="gray", lw=0.3),
            arrowprops=dict(arrowstyle="->", connectionstyle="arc3,rad=0.0", fc="black", lw=0.5)
        )

    # 6. Final Plot Styling

    plt.title(f'Price Distribution of all Listings in {json_file_name.replace(".json", "").capitalize()}',
              fontsize=16, fontweight='bold', pad=20)
    plt.xlabel(f'Listings (Sorted by Price from Lowest to Highest)', fontsize=12)
    plt.ylabel('Price (USD)', fontsize=12)
    plt.grid(True, which='major', linestyle=':', linewidth=0.7, alpha=0.6)

    # Remove X-ticks as before to prevent overcrowding
    ax.set_xticks([])

    # Adjust Y-axis format to show $ and commas for prices
    y_formatter = plt.FuncFormatter(lambda x, p: f'${x:,.0f}')
    plt.gca().yaxis.set_major_formatter(y_formatter)

    # Add Legend
    plt.legend(loc='upper left', fontsize=10)

    # 7. Add Statistics Output to the JPEG (Text Box - Clean Placement)
    # Use the clean, top-centered placement (figure coordinates)
    stat_text_for_box = (
        f"Avg. Price: {stats['avg_price']} | "
        f"Avg. Beds: {stats['avg_beds']} | "
        f"Avg. Baths: {stats['avg_baths']} | "
        f"Avg. Sq. Ft.: {stats['avg_sqft']} sq ft | "
        f"Top Agency: {stats['agency_text']}"
    )

    # Position the text box above the main plot area
    ax = plt.gca()
    ax.text(0.50, 0.92, stat_text_for_box,
            transform=ax.transAxes,
            fontsize=10,
            ha='center',
            va='top',
            bbox=dict(boxstyle="round,pad=0.5",
                      fc="white",
                      alpha=0.85,
                      ec="gray",
                      linewidth=0.5))

    # Ensure layout is tight and adjust for the top text box
    plt.tight_layout(rect=[0, 0, 1, 0.9])

    # 8. Save as JPEG
    plt.savefig(output_file_name, format='jpeg', dpi=300)
    print(f"Success! Plot and analysis exported to '{output_file_name}'")
    plt.close()


# Execute the script
if __name__ == "__main__":
    # This block allows Plot.py to be executed directly with a filename argument
    if len(sys.argv) > 1:
        JSON_FILE_NAME = sys.argv[1]
        base_name = JSON_FILE_NAME.replace('.json', '')
        OUTPUT_FILE_NAME = f'price_analysis_{base_name}.jpeg'

    generate_analysis_plot(JSON_FILE_NAME, OUTPUT_FILE_NAME)